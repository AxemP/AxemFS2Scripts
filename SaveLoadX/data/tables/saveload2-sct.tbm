#Conditional Hooks
$Application: FS2_Open

$On Game Init:
[

SaveState = {}

function SaveState:Init()

	ba.print("SAVELOAD: Initialization begun...!\n")

	self.WorksOutOfCampaign = true
	
	if self.WorksOutOfCampaign or mn.isInCampaign() then
		self.Enabled = true
	end
	
	if not self.Enabled then
		return
	end
	
	self.CurrentIndex = nil
	self.WingList = {}
	self.List = self:GetAllCurrentShips()


	self.CuedList = {}
		
	local playerData = ba.getCurrentPlayer()
	
	self.SaveFilename = playerData:getName() .. "_" .. mn.getMissionFilename() .. ".sav"
	
	if cf.fileExists(self.SaveFilename, "data/config") then
		self.LoadedData = axemParse:ReadJSON(self.SaveFilename, "data/config")
	else
		self.LoadedData = {}
	end
	
	self.AssistList = {}
	self.AssistHP = nil
	self.AssistAmmo = nil
	
	self.ShipFlags = {"invulnerable", "protect-ship", "beam-protect-ship", "flak-protect-ship", "laser-protect-ship", "missile-protect-ship", "cargo-known", "hidden-from-sensors", "stealth", "friendly-stealth-invisible", "afterburners-locked", "primaries-locked", "secondaries-locked", "free-afterburner-use"}

end

function SaveState:AddWing(wingname)

	for i,v in ipairs(self.WingList) do
		if v == wingname then return end
	end
	
	ba.print("SAVELOAD: New wing found, " .. wingname ..",  adding to Wing List\n")
	self.WingList[#self.WingList+1] = wingname
	
	ba.print("SAVELOAD: Number of wings: " .. #self.WingList .."\n")

end

--This just gets called at mission start so we have the beginnings of our master list.
function SaveState:GetAllCurrentShips()

	ba.print("SAVELOAD: Getting ships present at start...\n")

	local t = {}
	local numShips = #mn.Ships
	
	for i=1, numShips do
		local thisShip = mn.Ships[i]
		if thisShip and thisShip:isValid() then
			t[#t+1] = thisShip.Name
			ba.print("SAVELOAD: Found " .. thisShip.Name .. ", adding to Ship List\n")
			if thisShip:getWing() and thisShip:getWing():isValid() then
				self:AddWing(thisShip:getWing().Name)
			end
		end
	
	end
	
	ba.print("SAVELOAD: Found " .. #t .. " items.\n")
	
	return t

end

--When a ship arrives, we add it to THE LIST, which we'll check when we're saving. We want to catch every ship that arrives, even ones that might have died/left already, so that's why we're not just checking mn.Ships[].
function SaveState:AddShip(ship)

	ba.print("SAVELOAD: " .. ship.Name .. " arrived, adding to Ship List\n")

	if self.Enabled then
		self.List[#self.List+1] = ship.Name
		if ship:getWing() and ship:getWing():isValid() then
			self:AddWing(ship:getWing().Name)
		end
	end
	
	if self.CurrentIndex then
		self:CheckLateData(ship)
	end

end

function SaveState:CheckLateData(ship)

	ba.print("SAVELOAD: Checking " .. ship.Name .. " for late data\n")
	local thisShipName = ship.Name
	
	for i=1, #self.CuedList do
		if self.CuedList[i] and self.CuedList[i] == thisShipName then
			local thisloadeddata = self.LoadedData[self.CurrentIndex]
			local data = thisloadeddata[thisShipName]
						
			if data then self:ApplyLateData(ship,data) end
			
			return
		end
	end

end

 --Collecting data from a ship
function SaveState:GetShipData(shipname)

	ba.print("SAVELOAD: Getting ship data from " .. shipname .. "\n")

	local t = {}
	
	t.Name = shipname
		
	t.IsInMission = mn.evaluateSEXP("(is-in-mission !" .. t.Name .. "!)")
	t.HasArrived = mn.evaluateSEXP("(has-arrived-delay 0 !" .. t.Name .. "!)")
	t.HasBeenDestroyed = mn.evaluateSEXP("(is-destroyed-delay 0 !" .. t.Name .."!)")
	t.HasDeparted = mn.evaluateSEXP("(has-departed-delay 0 !" .. t.Name .."!)")
		
	if t.IsInMission then
	
		local ship = mn.Ships[shipname]
	
		if ship and ship:isValid() then
		
			--Get Class
			t.Class = ship.Class.Name
			
			--Is this part of a wing?
			if ship:getWing() and ship:getWing():isValid() then
				t.Wing = ship:getWing().Name
			end
			
			--Get HP
			t.HP = math.floor((ship.HitpointsLeft / ship.HitpointsMax) * 100)
		
			--Get Shields
			if ship.Shields and ship.Shields:isValid() then
				t.Shields = math.floor((ship.Shields.CombinedLeft / ship.Shields.CombinedMax) * 100)
			end
			
			--Get Armor (LateData)
			t.HullArmor = ship.ArmorClass 
			t.ShieldArmor = ship.ShieldArmorClass
			
			--Get Team (LateData)
			t.Team = ship.Team.Name
						
			--Get Countermeasures (LateData)
			t.Countermeasures = ship.CountermeasuresLeft
			
			--Get Orders (LateData)
			t.Orders = {}
			for i=1, #ship.Orders do
				local order = ship.Orders[i]
				
				tt = {}
				tt.Priority = order.Priority
				tt.Type = self:GetAIOrderFromEnum(order:getType())
				if (order:getType() == ORDER_WAYPOINTS) or (order:getType() == ORDER_WAYPOINTS_ONCE) then
					tt.Target = order.Target:getList().Name
				else
					tt.Target = order.Target.Name
				end
				tt.Subsystem = order.TargetSubsystem.Name
				
				t.Orders[i] = tt
				
			end
			
			--Get Flags (LateData)
			t.Flags = {}
			for i=1, #self.ShipFlags do
				if mn.evaluateSEXP("(are-ship-flags-set !" .. shipname .. "! !" .. self.ShipFlags[i] .. "!)") then
					t.Flags[i] = true
				else
					t.Flags[i] = false
				end
			end
			
			--Subsystem craziness
			local numSubsys = #ship
			
			if numSubsys > 0 then
				t.Subsystems = {}
				
				for i=1, numSubsys do
					local thisSubsys = ship[i]
					local ss = {}
					
					ss.HP = math.floor((thisSubsys.HitpointsLeft / thisSubsys.HitpointsMax) * 100)
					ss.Armor = thisSubsys.ArmorClass
					
					if thisSubsys:isTurret() then
					
						ss.TurretLocked = thisSubsys.TurretLocked -- (LateData)
					
						if thisSubsys.PrimaryBanks and thisSubsys.PrimaryBanks:isValid() then
							ss.PBanks = {}
							for j=1, #thisSubsys.PrimaryBanks do
								if thisSubsys.PrimaryBanks[j] and thisSubsys.PrimaryBanks[j]:isValid() then
									ss.PBanks[j] = {}
									ss.PBanks[j].Class = thisSubsys.PrimaryBanks[j].WeaponClass.Name
									ss.PBanks[j].AmmoLeft = math.floor((thisSubsys.PrimaryBanks[j].AmmoLeft / thisSubsys.PrimaryBanks[j].AmmoMax) * 100)
								end
							end
						end
						
						if thisSubsys.SecondaryBanks and thisSubsys.SecondaryBanks:isValid() then
							ss.SBanks = {}
							for j=1, #thisSubsys.SecondaryBanks do
								if thisSubsys.SecondaryBanks[j] and thisSubsys.SecondaryBanks[j]:isValid() then
									ss.SBanks[j] = {}
									ss.SBanks[j].Class = thisSubsys.SecondaryBanks[j].WeaponClass.Name
									ss.SBanks[j].AmmoLeft = math.floor((thisSubsys.SecondaryBanks[j].AmmoLeft / thisSubsys.SecondaryBanks[j].AmmoMax) * 100)
								end
							end
						end
					end
					
					t.Subsystems[i] = ss
					
				end
			end
				
			if ship.PrimaryBanks and ship.PrimaryBanks:isValid() then
				t.PBanks = {}
				for i=1, #ship.PrimaryBanks do
					t.PBanks[i] = {}
					t.PBanks[i].Class = ship.PrimaryBanks[i].WeaponClass.Name
					t.PBanks[i].AmmoLeft = math.floor((ship.PrimaryBanks[i].AmmoLeft / ship.PrimaryBanks[i].AmmoMax) * 100)
				end
			end
			
			if ship.SecondaryBanks and ship.SecondaryBanks:isValid() then
				t.SBanks = {}
				for i=1, #ship.SecondaryBanks do
					t.SBanks[i] = {}
					t.SBanks[i].Class = ship.SecondaryBanks[i].WeaponClass.Name
					t.SBanks[i].AmmoLeft = math.floor((ship.SecondaryBanks[i].AmmoLeft / ship.SecondaryBanks[i].AmmoMax) * 100)
				end
			end
			
			if ship == hv.Player then
			
				t.AfterburnerFuelLeft = ship.AfterburnerFuelLeft 
				t.WeaponEnergyLeft = ship.WeaponEnergyLeft
			
			end
			
			t.Position = {}
			t.Position.x = ship.Position.x
			t.Position.y = ship.Position.y
			t.Position.z = ship.Position.z
			
			t.Orientation = {}
			t.Orientation.p = ship.Orientation.p
			t.Orientation.b = ship.Orientation.b
			t.Orientation.h = ship.Orientation.h

			t.Velocity = {}
			t.Velocity.x = ship.Physics.Velocity.x
			t.Velocity.y = ship.Physics.Velocity.y
			t.Velocity.z = ship.Physics.Velocity.z
		
		end
		
	end

	return t, t.Name

end

function SaveState:GetWingData(wingname)

	ba.print("SAVELOAD: Getting wing data from " .. wingname .. "\n")

	local t = {}
	
	t.Name = wingname
		
	t.HasArrived = mn.evaluateSEXP("(has-arrived-delay 0 !" .. wingname .. "!)")
	t.HasBeenDestroyed = mn.evaluateSEXP("(is-destroyed-delay 0 !" .. wingname .."!)")
	t.HasDeparted = mn.evaluateSEXP("(has-departed-delay 0 !" .. wingname .."!)")
	
	return t, t.Name

end

function SaveState:CheckList(t, data)

	for i,v in ipairs(t) do
		if v == data then return true end
	end
	
	return false

end

 --This is what lua-savestate-save calls
 --We go through THE LIST and nab all of the ship data which will go into self.LoadedData which is what will get saved.
 --We use the ship name as a key for the data table for ease of retrival and checking later. This might take a bit more CPU time, but we can probably spare it.
function SaveState:SaveAll(index, ...)

	ba.print("SAVELOAD: ***** BEGINNING SAVE STATE! *****\n")

	if not self.Enabled then return false end

	local data = {}
	
	local exclusionList = {}
	
	for i, v in ipairs(arg) do
		ba.print("SAVELOAD: Adding " .. v[1] .. " to exclusion list\n")
		exclusionList[#exclusionList+1] = v[1]
	end
		
	for i, entry in ipairs(self.List) do
		if not self:CheckList(exclusionList,entry) then 
			shipdata,key = self:GetShipData(entry)
			data[key] = shipdata
		end
	end
	
	data.Wings = {}
	
	for i, entry in ipairs(self.WingList) do
		if not self:CheckList(exclusionList,entry) then
			wingdata,key = self:GetWingData(entry)
			data.Wings[key] = wingdata
		end
	end
	
	self.LoadedData[index or #self.LoadedData+1] = data

	ba.print("SAVELOAD: Writing save data to file " .. self.SaveFilename .. " with save index " .. index .. "\n")
	axemParse:WriteJSON(self.LoadedData, self.SaveFilename, "data/config")

end

 --This is what lua-savestate-load calls
 --Determinations are used to figure out how to apply the data. If the ship is present, we can apply it now. If not, we'll need to put it in the parsed object data. We also check if the ship is blown up or departed, where we can instantly and forcefully apply these things.
function SaveState:LoadAll(index)

	if not self.Enabled then return false end
	
	ba.print("SAVELOAD: ***** BEGINNING LOAD STATE! *****\n")

	if not index then
		ba.print("SAVE STATE: no index specified, aborting load data.\n")
		return
	else
		self.CurrentIndex = index
	end
	
	local thisloadeddata = self.LoadedData[self.CurrentIndex]
	
	if not thisloadeddata then
		ba.print("SAVE STATE: index " .. self.CurrentIndex .. " not found, aborting load data.\n")
		return
	end
	
	--Apply saved data to ships that are present
	
	local numShips = #mn.Ships
	
	for i=1, numShips do
		local thisShip = mn.Ships[i]
		if thisShip and thisShip:isValid() then
			local thisShipName = thisShip.Name
			local data = thisloadeddata[thisShipName]
			
			if data then
				if data.IsInMission then --Present from the start and was alive during save...
					self:ApplyData(thisShip,data)
				else
					if data.HasBeenDestroyed then -- or was destroyed
						self:InstantKill(thisShip)
					elseif data.HasDeparted then -- or had left
						self:InstantDepart(thisShip)
					end
				end
			end
		end
	end
	
	--Apply saved data to ships that have yet to arrive
	
	for thisShip in mn.getArrivalList() do
	
		local data = thisloadeddata[thisShip.Name]
		
		if data then
			if data.IsInMission then self:ApplyParseData(thisShip,data) end
			self.CuedList[#self.CuedList+1] = thisShip.Name
		end
		
	end

end

function SaveState:GiveOrders(ship,data)

	mn.runSEXP("(clear-goals !" .. ship.Name .. "!)")
	
	for i=1, #data.Orders do
	
		local thisOrder = data.Orders[i]
		local order = self:GetAIOrderFromString(thisOrder.Type)
		local targetShip = mn.Ships[thisOrder.Target]
		local targetSubsystem = thisOrder.Subsystem
		
		if order and targetShip and targetShip:isValid() then
			if targetSubsystem then
				ship:giveOrder(order, targetShip, targetShip[targetSubsystem], thisOrder.Priority)
			else
				ship:giveOrder(order, targetShip, nil, thisOrder.Priority)
			end
		end
		
	end

end

--Applying data to ships already present at time of load
function SaveState:ApplyData(ship,data,external)

	ba.print("SAVELOAD: Applying data to " .. ship.Name .. "\n")
	
	if ship.Class.Name ~= data.Class then
		ship.Class = tb.ShipClasses[data.Class]
	end
	
	ship.HitpointsLeft = (self:GetHP(data.HP,data.Name) / 100) * ship.HitpointsMax
	
	if data.Shields and ship.Shields and ship.Shields:isValid() then
		for i=1, #ship.Shields do
			ship.Shields[i] = (data.Shields / 100 / #ship.Shields) * ship.Shields.CombinedMax
		end
	end
	
	ship.ArmorClass = data.HullArmor
	ship.ShieldArmorClass = data.ShieldArmor
	
	ship.Team = mn.Teams[data.Team]
	
	if not external then
		self:GiveOrders(ship, data)
	end
	
	for i=1, #self.ShipFlags do
		if data.Flags[i] then
			mn.runSEXP("(alter-ship-flag !" .. self.ShipFlags[i] .. "! true true !" .. ship.Name .. "! )")
		end
	end
	
	ship.CountermeasuresLeft = data.Countermeasures
	
	local numSubsys = #ship
	
	if numSubsys > 0 then

		for i=1, numSubsys do
			local thisSubsys = ship[i]
			local ssdata = data.Subsystems[i]
			
			if ssdata.HP then
				thisSubsys.HitpointsLeft = (ssdata.HP / 100) * thisSubsys.HitpointsMax
			end
			
			if ssdata.Armor then
				thisSubsys.ArmorClass = ssdata.Armor
			end
			
			if thisSubsys:isTurret() then
			
				 thisSubsys.TurretLocked = ssdata.TurretLocked
			
				if thisSubsys.PrimaryBanks and thisSubsys.PrimaryBanks:isValid() then
					for j=1, #thisSubsys.PrimaryBanks do
						if thisSubsys.PrimaryBanks[j] and thisSubsys.PrimaryBanks[j]:isValid() then
							thisSubsys.PrimaryBanks[j].WeaponClass = tb.WeaponClasses[ssdata.PBanks[j].Class]
							thisSubsys.PrimaryBanks[j].AmmoLeft = (self:GetAmmo(ssdata.PBanks[j].AmmoLeft,data.Name)/100) * thisSubsys.PrimaryBanks[j].AmmoMax
						end
					end
				end
				
				if thisSubsys.SecondaryBanks and thisSubsys.SecondaryBanks:isValid() then
					for j=1, #thisSubsys.SecondaryBanks do
						if thisSubsys.SecondaryBanks[j] and thisSubsys.SecondaryBanks[j]:isValid() then
							thisSubsys.SecondaryBanks[j].WeaponClass = tb.WeaponClasses[ssdata.SBanks[j].Class]
							thisSubsys.SecondaryBanks[j].AmmoLeft = (self:GetAmmo(ssdata.SBanks[j].AmmoLeft,data.Name)/100) * thisSubsys.SecondaryBanks[j].AmmoMax
						end
					end
				end
			end
			
		end
	end
		
	if ship.PrimaryBanks and ship.PrimaryBanks:isValid() then
		for i=1, #ship.PrimaryBanks do
			ship.PrimaryBanks[i].WeaponClass = tb.WeaponClasses[data.PBanks[i].Class]
			ship.PrimaryBanks[i].AmmoLeft = (self:GetAmmo(data.PBanks[i].AmmoLeft,data.Name)/100) * ship.PrimaryBanks[i].AmmoMax
		end
	end
	
	if ship.SecondaryBanks and ship.SecondaryBanks:isValid() then
		for i=1, #ship.SecondaryBanks do
			ship.SecondaryBanks[i].WeaponClass = tb.WeaponClasses[data.SBanks[i].Class]
			ship.SecondaryBanks[i].AmmoLeft = (self:GetAmmo(data.SBanks[i].AmmoLeft,data.Name)/100) * ship.SecondaryBanks[i].AmmoMax
		end
	end
	
	if ship == hv.Player then
	
		ship.AfterburnerFuelLeft = data.AfterburnerFuelLeft
		ship.WeaponEnergyLeft = data.WeaponEnergyLeft
	
	end
	
	if not external then
		local newPosition = ba.createVector(data.Position.x, data.Position.y, data.Position.z)
		ship.Position = newPosition
		
		local newOrientation = ba.createOrientation(data.Orientation.p, data.Orientation.b, data.Orientation.h)
		ship.Orientation = newOrientation
	
		local newVelocity = ba.createVector(data.Velocity.x, data.Velocity.y, data.Velocity.z)
		ship.Physics.Velocity = newVelocity
	end
	
end

--Bang
function SaveState:InstantKill(ship)

	mn.runSEXP("(destroy-instantly !" .. ship.Name .. "! )")
	
end

--Bon voyage!
function SaveState:InstantDepart(ship)

	mn.runSEXP("(set-departure-info !" .. ship.Name .. "! !Hyperspace! !<no anchor>! 0 0 false)")
	ship:warpOut()

end

--Applying data to parse objects, or the objects that have yet to actually arrive in game yet.
function SaveState:ApplyParseData(ship,data)

	ba.print("SAVELOAD: Applying parse data to " .. ship.Name .. "\n")

	--Set the ship to arrive by hyperspace without warp-in to save the FREDder from having to do that
	mn.runSEXP("(set-arrival-info !" .. ship.Name .. "! !Hyperspace! !<any friendly>! 0 0 0 false)")
	
	if data.Wing then
		mn.runSEXP("(set-arrival-info !" .. data.Wing .. "! !Hyperspace! !<any friendly>! 0 0 0 false)")
	end

	if ship.ShipClass.Name ~= data.Class then
		ship.ShipClass = tb.ShipClasses[data.Class]
	end
	
	ship.InitialHull = self:GetHP(data.HP,data.Name)
	
	if data.Shields then
		ship.InitialShields = data.Shields
	end
	
	if ship.MainStatus.PrimaryBanks then
		for i, pbank in ipairs(data.PBanks) do
			if ship.MainStatus.PrimaryBanks[i] then
				ship.MainStatus.PrimaryBanks[i].Class = tb.WeaponClasses[pbank.Class]
				if pbank.AmmoLeft then ship.MainStatus.PrimaryAmmo[i] = self:GetAmmo(pbank.AmmoLeft,data.Name) end
			end
		end
	end
	
	if ship.MainStatus.SecondaryBanks then
		for i, sbank in ipairs(data.SBanks) do
			if ship.MainStatus.SecondaryBanks[i] then
				ship.MainStatus.SecondaryBanks[i].Class = tb.WeaponClasses[sbank.Class]
				if sbank.AmmoLeft then ship.MainStatus.SecondaryAmmo[i] = self:GetAmmo(sbank.AmmoLeft,data.Name) end
			end
		end
	end
		
	for i,subsys in ipairs(ship.Subsystems) do
	
		if data.Subsystems[i].HP then
			subsys.Damage = 100 - data.Subsystems[i].HP --We record the health in the save data, but the subsystem uses damage (silly Volition)
		end
		
		if subsys.PrimaryBanks and data.Subsystems[i].PBanks then
			for i, pbank in ipairs(data.Subsystems[i].PBanks) do
				if subsys.PrimaryBanks[i] then
					subsys.PrimaryBanks[i].Class = tb.WeaponClasses[pbank.Class]
					if pbank.AmmoLeft then subsys.PrimaryAmmo[i] = self:GetAmmo(pbank.AmmoLeft,data.Name) end
				end
			end
		end
		
		if subsys.SecondaryBanks and data.Subsystems[i].SBanks then
			for i, sbank in ipairs(data.Subsystems[i].SBanks) do
				if subsys.SecondaryBanks[i] then
					subsys.SecondaryBanks[i].Class = tb.WeaponClasses[sbank.Class]
					if sbank.AmmoLeft then subsys.SecondaryAmmo[i] = self:GetAmmo(sbank.AmmoLeft,data.Name) end
				end
			end
		end
	
	end
	
	local newPosition = ba.createVector(data.Position.x, data.Position.y, data.Position.z)
	ship.Position = newPosition
	
	local newOrientation = ba.createOrientation(data.Orientation.p, data.Orientation.b, data.Orientation.h)
	ship.Orientation = newOrientation
	
end

--Apply data to ships that aren't present at time of load and don't have the right parse data parameters
function SaveState:ApplyLateData(ship,data)

	ba.print("SAVELOAD: Applying late data to " .. ship.Name .. "\n")
	
	if data.HasBeenDestroyed then
		self:InstantKill(ship)
		return
	elseif data.HasDeparted then
		self:InstantDepart(ship)
		return
	end

	--Apply Armor
	ship.ArmorClass = data.HullArmor
	ship.ShieldArmorClass = data.ShieldArmor
	
	--Apply Team
	ship.Team = mn.Teams[data.Team]
	
	--Apply Countermeasures
	ship.CountermeasuresLeft = data.Countermeasures
	
	--Apply AI Orders
	self:GiveOrders(ship, data)
	
	--Apply Ship Flags
	for i=1, #self.ShipFlags do
		if data.Flags[i] then
			mn.runSEXP("(alter-ship-flag !" .. self.ShipFlags[i] .. "! true true !" .. ship.Name .. "! )")
		end
	end

	--Apply Turret Lock Status
	
	local numSubsys = #ship
			
	if numSubsys > 0 then
		
		for i=1, numSubsys do
			local thisSubsys = ship[i]
			
			if thisSubsys:isTurret() then
				ship[i].TurretLocked = data.Subsystems[i].TurretLocked
			end
		end
	end

end

--Why...
function SaveState:GetAIOrderFromEnum(orderEnum)

	local order
	
	if orderEnum == ORDER_ATTACK then
		order = "Attack"
	elseif orderEnum == ORDER_ATTACK then
		order = "Attack Any"
	elseif orderEnum == ORDER_DEPART then
		order = "Depart"
	elseif orderEnum == ORDER_DISABLE then
		order = "Disable"
	elseif orderEnum == ORDER_DISARM then
		order = "Disarm"
	elseif orderEnum == ORDER_DOCK then
		order = "Dock"
	elseif orderEnum == ORDER_EVADE then
		order = "Evade"
	elseif orderEnum == ORDER_FLY_TO then
		order = "Fly to"
	elseif orderEnum == ORDER_FORM_ON_WING then
		order = "Form on Wing"
	elseif orderEnum == ORDER_GUARD then
		order = "Guard"
	elseif orderEnum == ORDER_IGNORE_SHIP then
		order = "Ignore"
	elseif orderEnum == ORDER_KEEP_SAFE_DISTANCE then
		order = "Keep Safe Distance"
	elseif orderEnum == ORDER_PLAY_DEAD then
		order = "Play Dead"
	elseif orderEnum == ORDER_REARM then
		order = "Rearm"
	elseif orderEnum == ORDER_STAY_NEAR then
		order = "Stay Near"
	elseif orderEnum == ORDER_STAY_STILL then
		order = "Stay Still"
	elseif orderEnum == ORDER_UNDOCK then
		order = "Undock"
	elseif orderEnum == ORDER_WAYPOINTS then
		order = "Waypoints"
	elseif orderEnum == ORDER_WAYPOINTS_ONCE then
		order = "Waypoints Once"
	elseif orderEnum == ORDER_ATTACK_WING then
		order = "Attack Wing"
	elseif orderEnum == ORDER_GUARD_WING then
		order = "Guard Wing"
	else
		order = "None"
	end
	
	return order

end

--Why????
function SaveState:GetAIOrderFromString(order)

	--Waypoints orders will return nil because we can't start a waypoint mid-way through

	local orderEnum
	
	if order == "Attack" then
		orderEnum = ORDER_ATTACK
	elseif order == "Attack Any" then
		orderEnum = ORDER_ATTACK
	elseif order == "Depart" then
		orderEnum = ORDER_DEPART
	elseif order == "Disable" then
		orderEnum = ORDER_DISABLE
	elseif order == "Disarm" then
		orderEnum = ORDER_DISARM
	elseif order == "Dock" then
		orderEnum = ORDER_DOCK
	elseif order == "Evade" then
		orderEnum = ORDER_EVADE
	elseif order == "Fly to" then
		orderEnum = ORDER_FLY_TO
	elseif order == "Form on Wing" then
		orderEnum = ORDER_FORM_ON_WING
	elseif order == "Guard" then
		orderEnum = ORDER_GUARD
	elseif order == "Ignore" then
		orderEnum = ORDER_IGNORE_SHIP
	elseif order == "Keep Safe Distance" then
		orderEnum = ORDER_KEEP_SAFE_DISTANCE
	elseif order == "Play Dead" then
		orderEnum = ORDER_PLAY_DEAD
	elseif order == "Rearm" then
		orderEnum = ORDER_REARM
	elseif order == "Stay Near" then
		orderEnum = ORDER_STAY_NEAR
	elseif order == "Stay Still" then
		orderEnum = ORDER_STAY_STILL
	elseif order == "Undock" then
		orderEnum = ORDER_UNDOCK
	elseif order == "Waypoints" then
		orderEnum = nil
		--orderEnum = ORDER_WAYPOINTS
	elseif order == "Waypoints Once" then
		orderEnum = nil
		--orderEnum = ORDER_WAYPOINTS_ONCE
	elseif order == "Attack Wing" then
		orderEnum = ORDER_ATTACK_WING
	elseif order == "Guard Wing" then
		orderEnum = ORDER_GUARD_WING
	else
		orderEnum = nil
	end
	
	return orderEnum

end

--Solves world hunger
function SaveState:GetCurrentSaveIndex()

	return self.CurrentIndex or 0

end

 --Returns false if a ship is destroyed or departed in the current save slot or another specified one.
function SaveState:QueryStatus(object, index)

	if not self.Enabled then return false end

	if (not index) and (not self.CurrentIndex) then
		return true
	end

	local saveData
	
	--Wait is this actually a wing?
	
	if mn.Wings[object] and mn.Wings[object]:isValid() then
		saveData = self.LoadedData[index or self.CurrentIndex].Wings
	else
		saveData = self.LoadedData[index or self.CurrentIndex]
	end
	
	if saveData[object] then	
		if saveData[object].HasBeenDestroyed then
			return false
		elseif saveData[object].HasDeparted then
			return false
		else
			return true
		end
	end
	
	return false

end

function SaveState:ExternalLoad(index, mission, ...)

	ba.print("SAVELOAD: Beginning External Load!\n")

	if mission ~= self.ExternalMission then self:LoadExternalData(mission) end
	
	local data = self.ExternalData
	
	if data and data[index] then
	
		local saveData = data[index]
	
		for i, v in ipairs(arg) do
			local ship = v[1]
			
			ba.print("SAVELOAD: Attempting to load data for " .. ship .. "\n")
			
			if saveData[ship] and mn.Ships[ship] then
				local thisShip = mn.Ships[ship]
				self:ApplyData(thisShip,saveData[ship],true)
			end
		end
	end
	
	ba.print("SAVELOAD: Finished External Load!\n")
	
end

function SaveState:LoadExternalData(mission)

	ba.print("SAVELOAD: Loading external data, " .. mission .. "\n")

	local playerData = ba.getCurrentPlayer()
	local tempmissionfilename = playerData:getName() .. "_" .. mission .. ".sav"
	
	self.ExternalMission = mission
	
	tempmissionfilename = self:StripFS2(tempmissionfilename)
	self.ExternalData = axemParse:ReadJSON(tempmissionfilename, "data/config")

end

 --Checks to see if a save slot exists or not. We can also look at other mission save states.
function SaveState:Exists(index, mission)

	if not self.Enabled then return false end
	
	local data
		
	if not mission then
		data = self.LoadedData
	else
		if mission ~= self.ExternalMission then self:LoadExternalData(mission) end
		data = self.ExternalData
	end
	
	if data then
		if not index then
			if #data > 0 then
				return true
			end
		else
			if data[index] then
				return true
			end
		end
	end
	
	return false

end

 --Anti-frustration measure so someone might not be stuck at 2% hull on checkpoint load
function SaveState:AssistAdd(minhull, minammo, ...)

	self.AssistHP = minhull or 0
	self.AssistAmmo = minammo or 0
	
	for i,v in ipairs(arg) do
	
		self.AssistList[v[1]] = true
	
	end

end

 --These special functions might intervene if the ship is on the AssistList by increasing starting HP/Ammo
function SaveState:GetHP(hp,ship)

	if self.AssistHP and self.AssistList[ship] and hp then
		if hp < self.AssistHP then
			return self.AssistHP
		end
	end
	
	return hp or 100

end

function SaveState:GetAmmo(ammo,ship)

	if self.AssistAmmo and self.AssistList[ship] and ammo then
		if ammo < self.AssistAmmo then
			return self.AssistAmmo
		end
	end
	
	return ammo or 0

end

 --Clears save data
function SaveState:Clear(index)

	if not index then
		self.LoadedData = {}
		cf.deleteFile(self.SaveFilename, "data/config")
	else
		self.LoadedData[index] = nil
		axemParse:WriteJSON(self.LoadedData, self.SaveFilename, "data/config")
	end

end

 --I TOLD them no .fs2 extension, but there's a chance they won't listen!
function SaveState:StripFS2(s)

	local pos = s:find(".fs2", -4, true)

	if pos then
		name = s:sub(1,pos-1)
	end
		
	return s

end

--Lua SEXP definitions
mn.LuaSEXPs["lua-savestate-save"].Action = function(index, ...) SaveState:SaveAll(index, ...) end
mn.LuaSEXPs["lua-savestate-load"].Action = function(index) SaveState:LoadAll(index) end
mn.LuaSEXPs["lua-savestate-load-external"].Action = function(index, mission, ...) return SaveState:ExternalLoad(index, mission, ...) end
mn.LuaSEXPs["lua-savestate-shipstatus"].Action = function(name, index) return SaveState:QueryStatus(name, index) end
mn.LuaSEXPs["lua-savestate-getindex"].Action = function() return SaveState:GetCurrentSaveIndex() end
mn.LuaSEXPs["lua-savestate-check"].Action = function(index, mission) return SaveState:Exists(index, mission) end
mn.LuaSEXPs["lua-savestate-assist"].Action = function(minhull, minammo, ...) return SaveState:AssistAdd(minhull, minammo, ...) end
mn.LuaSEXPs["lua-savestate-clear"].Action = function(index) SaveState:Clear(index) end

]

$State: GS_STATE_GAME_PLAY
$On Gameplay Start:
[
	SaveState:Init()
]

$On Ship Arrive:
[
	SaveState:AddShip(hv.Ship)
]

$On Frame:
[
	--PrintDebug(SaveState.List)
	--PrintDebug(SaveState.LoadedData)
]

#End